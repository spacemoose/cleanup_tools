* Update the for loop

** Different types:
   - 0 :: iter declaration in for definition.
   - 1 :: iter declared before for loop.
   - 2 :: index counter in for loop.
   - 3 :: index counter outside for loop (harder).

** Iter declaration in for loop.
   Follows the pattern:

   for ( iter-typename iter-name = container_name.begin();
         iter-name !=

** Implementation challenges.

   ter

* Thoughts --

  - I want to be able to modify code within a block.
  - Each block can contain subblocks.
  - Each block knows its begin and its end.
  - When I modify code I make insertions and deletions to the local
    copy, which changes the positions of the beginnings and ends of
    the blocks.


  When I modify code within a block, this will invalidate the positions
  stored in the rest of the blocks.  What are the possiblities to
  handle this?

  1. Figure out how the blocks changed, and update the following positions.
  2. Rescan the file, updating the blocks.


  When I think of all the different things that can go wrong with
  option 1 -- what if I create a new block?  Can I overflow the
  positions?  I think option 2 is the easiest.  It does make my
  recursive mod algo a little trickier.

  So how does the recursive mod algo work?   Let's just consider the
  concrete example of updating for loops.

** int rec_apply (cur, end, ...)  // return # modifications made.
   while (cur != end)
   {
        uint total_chgs = 0;
        uint nchanges   = rec_apply(cur);
		if nchanges != 0
	        update_blocks(cur, end);

		++cur;
   }
